## Http File Ring — bottleneck audit

- Горячий путь сервера обильно засорён синхронным `std.debug.print` (см. `src/http.zig:142`, `188`, `196`, `433`, `481`, `493`, `505`; `src/mock_service.zig:30`, `40`). Каждый PUT генерирует 5–6 вызовов, stdout/stderr блокируют поток, и мы получаем десятки тысяч syscalls в секунду. Это основной предел ~3k блоков/с. Отключение логов увеличивает пропускную способность кратно.
- Внутри PUT остаются blocking-вызовы вне `io_uring`: `posix.write` на докачку тела из буфера (`src/http.zig:188`), два `posix.pipe()` на каждую транзакцию (`src/http.zig:178`), `posix.recv` для чтения хеша (`src/http.zig:515`). Они добавляют context switch’и и сериализуют обработку.
- Хеш вычисляется через общий AF_ALG socket (`src/http.zig:473`, `505`, `515`), который обслуживает запросы последовательно: пока не прочитан digest предыдущего блока, следующий splice не стартует. Для кратного роста rps нужно распараллелить (несколько operation sockets, очередь) либо считать SHA256 в пользователе.

### Рекомендации

1. Выключить/уровнем понизить `std.debug.print` в hot-path и повторить бенчмарк.
2. Минимизировать blocking syscalls: пул pipe’ов, offload hash read в `io_uring` или выделенный поток.
3. При необходимости снять профилировку CPU (`perf`, `strace -c`) уже без логов, чтобы подтвердить следующее узкое место.
