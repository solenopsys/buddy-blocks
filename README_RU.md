# Buddy Blocks Storage Server

Buddy Blocks — это сервер блочного хранения с адресацией по хешу, написанный на Zig. Он опирается на Linux `io_uring`, LMDBX и наш собственный buddy-аллокатор, чтобы обеспечивать производительность уровня S3 на недорогом железе, включая одноплатные компьютеры.

## Обзор

- Высокопроизводительный HTTP API для PUT/GET/DELETE блоков размером от 4 КБ до 512KB
- Рабочие потоки на `io_uring` с безлоковыми SPSC-очередями
- Единственный контроллер владеет транзакциями LMDBX и выполняет батчинг
- Buddy-аллокатор держит один предварительно выделенный файл данных без фрагментации
- Проектирован для децентрализованных сетей и узлов с ограниченными ресурсами

## Цели проекта

- Создать промышленное блочное хранилище для децентрализованных сетей
- Уверенно работать на SBC за $10 (Orange Pi / Raspberry Pi) с 1–2 ГБ RAM
- Предложить профиль производительности сопоставимый с S3-совместимыми системами, сохраняя простоту эксплуатации и аудита

## Принципы дизайна

1. **Опираемся на экспертов** — `io_uring` (~50k строк) для асинхронного I/O, LMDBX (~40k строк) для B-tree и транзакций, ~1k строк Zig-кода для интеграции.
2. **Пусть ядро делает тяжелую работу** — батчированные syscalls, ring buffers, memory-mapped LMDBX, прямые записи по смещению снижают нагрузку на CPU.
3. **Один файл — миллионы блоков** — все данные хранятся в одном файле, без миллиона inode и path lookup.
4. **Адаптивные размеры блоков** — buddy-аллокатор обслуживает классы 4 КБ–512Kb, минимизируя внутреннюю фрагментацию.
5. **Криптографическая целостность** — SHA-256 как базовый идентификатор, проверенный в неблагоприятных условиях.
6. **Масштабируемость слоями** — компактный фундамент сегодня, готовый к репликации, DHT, erasure coding и proof-of-storage завтра.

## Обзор архитектуры

```
  ┌────────────────────┐
  │   Client Requests  │   порт 10001
  └──────────┬─────────┘
             │  SO_REUSEPORT
       ┌─────┴─────┬─────┬─────┐
  ┌────▼───┐ ┌────▼┐ ┌──▼──┐ ┌▼────┐
  │Worker0 │ │Wkr1 │ │Wkr2 │ │Wkr3 │   HTTP-воркеры на io_uring
  └────┬───┘ └────┬┘ └──┬──┘ └┬────┘
       │ Безлоковые SPSC-очереди (вход/выход на воркера)
       └───────────┬───────────┬───────────┘
                   │
            ┌──────▼───────┐
            │  Controller  │   батчирует операции LMDBX
            └──────┬───────┘
                   │
            ┌──────▼───────┐
            │   LMDBX DB   │   hash → {offset, size}
            └──────────────┘
```

### Роли компонентов

- **HTTP-воркеры (`src/worker/`)** — принимают соединения, считают SHA-256, управляют локальными пулами свободных блоков и выполняют I/O через `io_uring`.
- **Контроллер (`src/controller/`)** — единственный поток, работающий с LMDBX; батчит allocate/free/get в одной транзакции и отправляет ответы воркерам.
- **Buddy-аллокатор (`buddy_allocator/`)** — ведёт состояние по классам размеров и мгновенно переиспользует освобожденные блоки.
- **Очереди (`lib/` SPSC)** — каналы запросов и ответов на воркер, без блокировок.
- **Пулы блоков** — каждый воркер кеширует блоки нужных размеров для немедленной записи.

### Жизненный цикл воркера

1. **Инициализация** — воркер проверяет пулы по каждому классу размеров. Если свободных блоков меньше порога `target_free`, отправляет `allocate_block` контроллеру. Полученные блоки остаются в кеше.
2. **Основной цикл** — HTTP-парсинг, хеширование и `io_uring` обрабатываются в одном цикле по событиям завершения. В начале итерации быстрый чек дополняет пулы, как и при старте.
3. **Потоковые записи** — при PUT воркер сразу забирает блок нужного размера и стримит тело запроса прямо в выделенное смещение внутри общего файла.
4. **Ответы** — контроллер присылает подтверждения и данные (например, offset); воркер читает их из выходной очереди и завершает запрос.

Пока контроллер поддерживает целевые размеры пулов, запись не блокируется на аллокацию. Воркеры никогда не обращаются к LMDBX напрямую.

### Цикл контроллера

1. **Адаптивная пауза** — перед новым циклом контроллер применяет регулятор на основе текущего RPS, чтобы балансировать CPU и задержку.
2. **Сбор сообщений** — опустошает входящие очереди всех воркеров, раскладывая сообщения по типам (`get_address`, `allocate_block`, `free_block`, `occupy_block`).
3. **Единая транзакция** — открывает транзакцию LMDBX и пакетно обрабатывает запросы:
   - Чтения (`get_address`) выполняются сразу, минимизируя задержку GET.
   - Освобождения вносятся в LMDBX и блоки возвращаются в buddy-аллокатор.
   - Запросы на выдачу блоков получают новые элементы из аллокатора.
   - `occupy_block` фиксирует соответствие `{hash → offset, size}`.
4. **Коммит и ответы** — транзакция коммитится один раз, результаты отправляются в выходные очереди воркеров, после чего цикл повторяется.

Единственный поток работы с LMDBX исключает гонки, а батчинг делает накладные расходы минимальными даже при высокой нагрузке.

## Модель ресурсов

- Все блоки находятся в одном файле данных; нет отдельных файлов и обхода директорий.
- Buddy-аллокатор поддерживает классы: 4 КБ, 8 КБ, 16 КБ, 32 КБ, 64 КБ, 128 КБ, 256 КБ, 512 КБ.
- Целевые значения свободных блоков по воркерам позволяют пополнять пулы без синхронизации.
- LMDBX хранит хеш, смещение и размер (~110 байт на запись при 10 млн объектов).

## Сборка

Требуется Zig 0.15.1+, Linux 5.1+ с поддержкой `io_uring`, LMDBX (зависимость `zig-lmdbx`).

### GNU/Linux (glibc)

```bash
# Однократно собираем LMDBX
git clone https://github.com/your-repo/zig-lmdbx ../zig-lmdbx
(cd ../zig-lmdbx && zig build -Dall=true)

# Сборка Buddy Blocks
zig build -Doptimize=ReleaseFast
# Итог: zig-out/bin/buddy-blocks-gnu
```

### Цель Alpine / musl

```bash
zig build -Dmusl=true -Doptimize=ReleaseFast
# Итог: zig-out/bin/buddy-blocks-musl
```

### Контейнер (Podman / Docker)

```bash
zig build -Doptimize=ReleaseFast
zig build -Dmusl=true -Doptimize=ReleaseFast
podman build -t buddy-blocks:latest .
# или
docker build -t buddy-blocks:latest .
```

## Запуск

### Локальный бинарник

```bash
LD_LIBRARY_PATH=../zig-lmdbx/zig-out/lib ./zig-out/bin/buddy-blocks-gnu
# или
zig build run
```

Сервер слушает на `0.0.0.0:10001`.

### Контейнер

```bash
podman run -d --name buddy-blocks \
  --privileged \
  -p 10001:10001 \
  buddy-blocks:latest
# или
docker run -d --name buddy-blocks \
  --privileged \
  -p 10001:10001 \
  buddy-blocks:latest
```

Флаг `--privileged` необходим для работы `io_uring` внутри контейнера.

### Быстрые проверки

```bash
podman logs buddy-blocks
curl -X PUT http://localhost:10001/block -d "test data"
curl http://localhost:10001/block/<hash>
```

## API

### PUT `/block`

Загружает блок и возвращает его SHA-256.

```bash
curl -X PUT --data-binary @file.bin http://localhost:10001/block
echo "Hello, World!" | curl -X PUT --data-binary @- http://localhost:10001/block
```

Ответ:
```
HTTP/1.1 200 OK
Content-Type: text/plain

a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e
```

Ограничение: максимальный размер блока — 1 МБ (в рамках поддерживаемых классов).

### GET `/block/<hash>`

Возвращает блок по хешу содержимого.

```bash
curl http://localhost:10001/block/<hash> -o output.bin
```

### DELETE `/block/<hash>`

Удаляет блок и возвращает место в аллокатор.

```bash
curl -X DELETE http://localhost:10001/block/<hash>
```

## Конфигурация

Параметры можно изменить в `src/main.zig`:

```zig
const Config = struct {
    port: u16 = 10001,
    num_workers: u8 = 4,
    controller_cycle_ns: i128 = 20_000,
    queue_capacity: usize = 4096,
};
```

Контроллер динамически адаптирует паузу между циклами на основе последнего RPS, чтобы балансировать латентность и загрузку CPU.

## Производительность

Бенчмарки (Zig 0.15.1, Linux 6.16.11):

- Контейнер (Alpine/musl): PUT 3 398 ops/s (13.27 MB/s), GET 1 774 rps, ~1.13 мс задержка.
- Хост (glibc): PUT 3 567 ops/s (13.93 MB/s), GET 1 753 rps, ~1.14 мс задержка.

Микротесты аллокатора при 10 млн блоков:

- Allocate: 23 097 ops/s
- Get: 72 811 ops/s
- Free: 31 376 ops/s
- LMDBX: ~1.1 ГБ (≈110 байт на запись)

Профиль на NVMe:

- Метаданные: ~10 мкс
- Чтение блока 1 МБ: ~200 мкс
- Пропускная способность: ≈5 ГБ/с при 5k ops/s
- `io_uring` позволяет параллельные очереди до ~20 ГБ/с

### Нагрузочное тестирование

```bash
cd tests
go run rps.go -blocks 1000 -concurrency 2
# -duration 10s для длительной нагрузки
```

## Дорожная карта

- Репликация между узлами
- Поиск через DHT / gossip
- Erasure coding поверх фиксированных блоков
- Интеграция механизмов proof-of-storage

## Тестирование

```bash
zig build test
cd tests && python3 test_basic_operations.py
```

## Лицензия

Apache 2.0
