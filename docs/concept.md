Новая концепция. 
  - Есть воркеры которые являются полноценными потоками linux http + ring и цепляются на общий порт
  - есть отдельный поток контроллер который так-же содержит lmbdx 
  - воркеры и контроллеры соеденены spsc очередями (отда очереть на выход другая на вход)
  - между воркерами и контроллерами передаются сообщения разных типов. 
  -  (allocateBlock, accupyBlock, releaseBlock, getAddressByHash, error) внутри собщений есть обратный адрес воркера и результаты также в отдельных типах
  - в место горячего выделения блока по запросу worker (заранее накапливает нужное количество пустых блоков для записи каждого размера)
  - воркер динамически поддерживает это количество блоков если количество недостаточно шлет заявки на веделение блоков. 
  - транзакционная обработка 
    - в контроллере есть цикл обработки
    - в цикле есть динамическая пауза на 100 микросекунд (если нет нагрузки то пауза 100 если уже истелка мгновенное пролоджение цикла)
    - певый шаг вытаскивание всех сообщений из всех входящий оцередей от воркеров (сообщения раскладываются по типам в массивы)
    - дальше в одной общей транзакции lmdbx идут следущие батчи операций
      - батч освобождения блоков (результаты добавляются массив результатов)
      - батч занятия блоков (результаты добавляются массив результатов)
      - батч выделения блоков (результаты добавляются массив результатов)
      - батч получения адреса блока по хешу (результаты добавляются массив результатов)
    - после комита общей транзакции воркерам рассылаются по даресам сообщения с результатами
  - то есть тут ни каких проблем нет с конкуренцией в работе потоков с файлом так воркеры работают с заранее выданными им блоками и как бы являются владельцами этих сегментов файла.   
    


# План
1. Максимальный размер блока сделать 512kb
2. Изменить тип данных для хранения размера блока до u8
3. Увеличить размер рабочих буферов uring и реально передавать крупные куски за одно `read`/`write`, а не резать на 4 KB.
   const BUFFER_SIZE = 64 * 1024; // 64 KB на операцию
   const NUM_BUFFERS = 8; //  ~512 kb общей памяти
4. добавить в проект либу очередей https://github.com/freref/spsc-queue
5. (переход к многопоточному серверу) разделить базовые единицы кода на  worker и controller (при том воркеры это полноценные серверы с собственным ring )
6. связать worker и controller через SPSC очередь
7. сделать типы сообщений для очереди
8. Настройку размеров буферизации блоков сделать настройку общую где будет указано сколько блоков для каждого размера

