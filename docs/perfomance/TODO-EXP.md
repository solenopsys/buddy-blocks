# План устранения узких мест производительности

Отсортировано от самых критичных до незначительных проблем.

---

## 1. КРИТИЧНО: Устранить двойное выделение блоков (allocate + occupy)

**Файл:** `src/controller/handler.zig:31-69`, `src/worker/worker.zig:259-347`

**Проблема:**
- Worker запрашивает `allocate_block` для пополнения пула (с временным хешом)
- При реальном PUT worker отправляет `occupy_block` (с настоящим хешом)
- Контроллер вызывает `BuddyAllocator.allocate()` **дважды** → двойная транзакция LMDB
- Резервные блоки остаются занятыми фиктивными хешами → утечка памяти + рост БД

**Решение:**
 Довести prefetch до конца:
  - Worker использует `acquire()` из пула для получения заранее выделенного блока
  - Контроллер в `handleOccupy` обновляет хеш БЕЗ повторного `allocate()`
  - Требует добавить `updateHash(block_num, new_hash)` в BuddyAllocator

**Выигрыш:** 2x снижение нагрузки на LMDB, устранение утечки памяти

---

## 2. КРИТИЧНО: Батчевая обработка транзакций LMDB

**Файл:** `src/controller/controller.zig:171`, `buddy_allocator.zig:103-137`

**Проблема:**
- Каждый `occupy_request` обрабатывается в отдельной LMDB транзакции
- BatchController собирает запросы, но обрабатывает их последовательно
- При высоком RPS это ограничивает throughput до 3-4k ops/s

**Решение:**
- Группировать весь батч `occupy_requests` в одну LMDB read-write транзакцию
- Убрать `std.Thread.Mutex` из BuddyAllocator (контроллер уже однопоточный)
- Опционально: асинхронный commit с буферизацией операций

**Выигрыш:** 3-4x увеличение throughput (от 3.5k до 12-15k ops/s)

---

## 3. ВЫСОКИЙ ПРИОРИТЕТ: Неблокирующая отправка ответов через io_uring

**Файл:** `src/worker/worker.zig:427, 475, 656, 759, 777, 792`

**Проблема:**
- Все ответы клиентам отправляются через блокирующий `posix.write()`
- При нагрузке с сотнями keep-alive соединений блокировка TCP подвешивает весь worker

**Решение:**
- Перейти на `io_uring.send()` или `io_uring.write()` для всех сетевых отправок
- Выставить сокеты в non-blocking режим
- Добавить обработку `OP_SEND` в event loop

**Выигрыш:** Устранение блокировок, повышение параллелизма на 2-3x

---

## 4. ВЫСОКИЙ ПРИОРИТЕТ: Устранить лишнее копирование данных в PUT

**Файл:** `src/worker/worker.zig:322-343`

**Проблема:**
- Тело запроса накапливается в `ArrayList` (первое копирование)
- Перед `io_uring.write()` создается новый буфер и данные копируются повторно
- Для блоков 4 КиБ - удвоение overhead, для 512 КиБ - существенная нагрузка

**Решение:**
- Использовать заранее выделенные/переиспользуемые буферы (пул буферов)
- Зарегистрировать буферы в `io_uring` (registered buffers)
- Или стримить данные напрямую в файл без промежуточного массива

**Выигрыш:** Снижение CPU usage на 30-40%, снижение давления на аллокатор

---

## 5. СРЕДНИЙ ПРИОРИТЕТ: Оптимизировать PauseRegulator

**Файл:** `src/controller/pause_regulator.zig:4-55`

**Проблема:**
- Стартовая пауза 1 мс слишком велика
- Переключение на 0 только при ≥1000 msg/s за последнюю секунду
- При умеренных нагрузках (<1000 RPS) контроллер искусственно тормозит

**Решение:**
- Уменьшить стартовую паузу до 10-100 μs
- Снизить порог активации (например, 100 msg/s вместо 1000)
- Обновлять метрику чаще (каждые 100 итераций вместо 1000)
- Добавить гистерезис для плавного перехода

**Выигрыш:** Устранение искусственного ограничения на умеренных нагрузках

---

## 6. СРЕДНИЙ ПРИОРИТЕТ: Pre-allocate емкость батч-буферов

**Файл:** `src/controller/controller.zig:109-116`

**Проблема:**
- `ArrayList` в `collectMessages()` постоянно делает realloc при росте
- На больших очередях вызывает лишние аллокации

**Решение:**
- При инициализации BatchController вызвать `ensureTotalCapacity()` для всех буферов
- Установить разумную начальную емкость (например, 1024 элемента)

**Выигрыш:** Снижение overhead аллокатора, стабильность латентности

---

## 7. НИЗКИЙ ПРИОРИТЕТ: Выравнивание буферов для O_DIRECT

**Файл:** `src/worker/worker.zig:327`

**Проблема:**
- При использовании `O_DIRECT` буферы должны быть выровнены на 4096 байт
- `allocator.alloc(u8, body.len)` не гарантирует выравнивание
- Может приводить к скрытым копиям или ошибкам ядра

**Решение:**
- Использовать `std.mem.alignedAlloc()` с выравниванием 4096
- Или использовать зарегистрированные в io_uring буферы (уже выровненные)

**Выигрыш:** Корректная работа с O_DIRECT, устранение потенциальных ошибок

---

## 8. НИЗКИЙ ПРИОРИТЕТ: Оптимизировать частоту fallocate

**Файл:** `src/infrastructure/buddy_allocator.zig` (createNewMacroBlock)

**Проблема:**
- Из-за утечки резервных блоков `fallocate(1 МиБ)` вызывается слишком часто
- После устранения п.1 эта проблема должна решиться автоматически

**Решение:**
- Исправить п.1 (двойное выделение)
- Мониторить частоту вызовов `createNewMacroBlock`

**Выигрыш:** Снижение overhead на расширение файла

---

## Ожидаемая производительность после оптимизаций

- **NVMe, 1 worker, 4 КиБ блоки:** 12 000 – 15 000 RPS (≈50–60 МБ/с)
- **NVMe, 8 workers, 4 КиБ блоки:** 80 000 – 100 000 RPS (≈320–400 МБ/с)
- **Текущая:** ~3 500 RPS (≈16 МБ/с) → улучшение в **25-30x**
